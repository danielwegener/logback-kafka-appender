<configuration>

    <appender class="ch.qos.logback.core.ConsoleAppender" name="STDOUT">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <target>System.out</target>
    </appender>
    <appender class="ch.qos.logback.core.ConsoleAppender" name="STDERR">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <target>System.err</target>
    </appender>

    <!-- This example configuration is probably most unreliable under
    failure conditions but wont block your application at all -->
    <appender class="com.github.rahulsinghai.logback.kafka.KafkaAppender"
        name="very-relaxed-and-fast-kafka-appender">
        <clientJaasConfPath>/kafka_2.12-2.1.1/jaas.conf</clientJaasConfPath>
        <deliveryStrategy
            class="com.github.rahulsinghai.logback.kafka.delivery.AsynchronousDeliveryStrategy"/>
        <!-- we don't care how the log messages will be partitioned  -->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>

        <!-- use async delivery. the application threads are not blocked by logging -->
        <kerb5ConfPath>/kafka_2.12-2.1.1/krb5.conf</kerb5ConfPath>

        <!-- wait indefinitely until the kafka producer was able to send the message -->
        <!--deliveryStrategy class="com.github.rahulsinghai.logback.kafka.delivery.BlockingDeliveryStrategy" >
            <timeout>0</timeout>
        </deliveryStrategy-->

        <!-- Optional parameter to use a fixed partition -->
        <!-- <partition>0</partition> -->

        <!-- Optional parameter to include log timestamps into the kafka message -->
        <!-- <appendTimestamp>true</appendTimestamp> -->

        <!-- each <producerConfig> translates to regular kafka-client config (format: key=value) -->
        <!-- producer configs are documented here: https://kafka.apache.org/documentation.html#newproducerconfigs -->
        <!-- bootstrap.servers is the only mandatory producerConfig -->
        <keyingStrategy class="com.github.rahulsinghai.logback.kafka.keying.NoKeyKeyingStrategy"/>
        <!-- don't wait for a broker to ack the reception of a batch.  -->
        <producerConfig>bootstrap.servers=localhost:9092</producerConfig>
        <!-- wait up to 1000ms and collect log messages before sending them as a batch -->
        <producerConfig>acks=0</producerConfig>
        <!-- even if the producer buffer runs full, do not block the application but start to drop messages -->
        <producerConfig>linger.ms=1000</producerConfig>
        <!-- define a client-id that you use to identify yourself against the kafka broker -->
        <producerConfig>max.block.ms=0</producerConfig>

        <!-- Kerberized Kafka cluster -->
        <producerConfig>client.id=${HOSTNAME}-${CONTEXT_NAME}-logback-relaxed</producerConfig>
        <producerConfig>security.protocol=SASL_PLAINTEXT</producerConfig>
        <producerConfig>sasl.kerberos.service.name=kafka</producerConfig>
        <topic>boring-logs</topic>

        <!-- there is no fallback <appender-ref>. If this appender cannot deliver, it will drop its messages. -->
    </appender>

    <!-- This example configuration is more restrictive and will try to ensure that every message
     is eventually delivered in an ordered fashion (as long the logging application stays alive) -->
    <appender class="com.github.rahulsinghai.logback.kafka.KafkaAppender"
        name="very-restrictive-kafka-appender">
        <appender-ref ref="STDERR"/>

        <deliveryStrategy
            class="com.github.rahulsinghai.logback.kafka.delivery.BlockingDeliveryStrategy">
            <!-- wait indefinitely until the kafka producer was able to send the message -->
            <timeout>0</timeout>
        </deliveryStrategy>
        <!-- ensure that every message sent by the executing host is partitioned to the same partition strategy -->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <!-- block the logging application thread if the kafka appender cannot keep up with sending the log messages -->
        <keyingStrategy
            class="com.github.rahulsinghai.logback.kafka.keying.HostNameKeyingStrategy"/>

        <!-- each <producerConfig> translates to regular kafka-client config (format: key=value) -->
        <!-- producer configs are documented here: https://kafka.apache.org/documentation.html#newproducerconfigs -->
        <!-- bootstrap.servers is the only mandatory producerConfig -->
        <producerConfig>bootstrap.servers=localhost:9092</producerConfig>
        <!-- restrict the size of the buffered batches to 8MB (default is 32MB) -->
        <producerConfig>buffer.memory=8388608</producerConfig>

        <!-- If the kafka broker is not online when we try to log, just block until it becomes available -->
        <producerConfig>metadata.fetch.timeout.ms=99999999999</producerConfig>
        <!-- define a client-id that you use to identify yourself against the kafka broker -->
        <producerConfig>client.id=${HOSTNAME}-${CONTEXT_NAME}-logback-restrictive</producerConfig>
        <!-- use gzip to compress each batch of log messages. valid values: none, gzip, snappy  -->
        <producerConfig>compression.type=gzip</producerConfig>

        <!-- Log every log message that could not be sent to kafka to STDERR -->
        <topic>important-logs</topic>
    </appender>

    <root level="info">
        <appender-ref ref="very-relaxed-and-fast-kafka-appender"/>
        <appender-ref ref="very-restrictive-kafka-appender"/>
    </root>
</configuration>
